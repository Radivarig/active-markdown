<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style>
        blockquote {
    border-left: 3px solid #ccc;
    font-style: italic;
    padding-left: 1em;
    margin-left: 0;
}
pre {
    color: #444;
    background: #fbfbfb;
    padding: 1em;
    border: 1px solid #ccc;
    max-height: 200px;
    overflow: scroll;
}
body {
    max-width: 690px;
    margin: 0 auto;
    padding: 2em 1em;
    font-family: Georgia;
    background: #fdfdfd;
    color: #0e0e0e;
}
p, blockquote {
    line-height: 1.5;
}
hr {
    border: 0;
    border-bottom: 1px solid #ccc;
    margin-top: 1.5em;
    margin-bottom: 1.5em;
}
.Variable {
    border: 1px solid rgba(0,0,255,0.8);
    padding: 0.1em;
    position: relative;
    border-radius: 3px;
}
.Variable .variable-label {
    font-size: 0.8em;
    background-color: yellow;
    border: 1px dotted #ccc;
    font-family: Menlo, Courier New, monospace;
}
.Variable .variable-label:before {
    content: "@";
}
.Variable.readonly {
    border-color: rgba(0,0,255,0.2);
}
.NumberVar .slider {
    width: 200px;
    position: absolute;
    bottom: 100%;
    left: -25px;
    display: none;
}
.NumberVar:hover .slider, .NumberVar:active .slider  {
    display: block;
}
.BinaryVar label, .BinaryVar input {
    cursor: pointer;
}
.GraphView {
    margin: 1em 0;
}
.GraphView .graph-title {
    text-align: center;
    font-weight: bold;
}
.GraphView .graph-canvas {
    width: 100%;
}

#raw {
    font-family: Menlo;
    white-space: pre;
    border-bottom: 1px solid #ccc;
    max-height: 0;
    overflow: hidden;
    -webkit-transition-property: max-height;
    -webkit-transition-duration: 0.5s;
}
#raw.visible {
    max-height: 10000px;
}
    </style>
</head>
<body>
    <div id="content"><h1>Active Markdown: an experiment</h1>
<p>A (hopefully) straightforward notation for adding interactivity to Markdown
documents, using the document’s own code blocks to provide the logic and
define the relationships between the variables.</p>
<p>Like so:</p>
<hr />
<p>Fuel usage is a function of <em>distance</em> divided by the rate of <em>consumption</em>.</p>
<pre><code>@fuel_usage = @distance / @mileage
</code></pre>
<p>Traveling <span class="live-text"  data-name="distance" data-config='["[0..200]"]'>100</span> miles in a car rated at <span class="live-text"  data-name="mileage" data-config='["[5..40]"]'>25</span>mpg uses <span class="live-text"  data-name="fuel_usage" data-config='[]'>4</span> gallons.</p>
<hr />
<p>The goal is to provide a simple notation for defining these variables and
linking them to the logic, so that such documents can be easily created and
read even in plaintext form, with minimal loss of information.</p>
<h2>Background</h2>
<h3>Regular Markdown</h3>
<p>Regular Markdown is great. It provides a way to have plaintext
“source code” for content, while still giving useful semantic formatting.</p>
<p>Its output is static, but it doesn't have to be.</p>
<h3>Tangle</h3>
<p>The amazing Bret Victor’s <a href="http://worrydream.com/Tangle/"><code>Tangle</code></a> library
makes it possible to build interactive documents with variables in text that
can be adjusted, and the output displayed by modifying the text, generating a
graph, and so on. While powerful, the library requires knowledge of HTML, CSS,
and JavaScript, and the result is effectively a small client-side webapp.
Also, the logic that drives the relationships between the variables is hidden.
It’s possible to <a href="http://worrydream.com/TenBrighterIdeas/">expose the source</a>,
but it’s still separate from the interactivity.</p>
<p>There are similar projects, like
<a href="http://www.rstudio.com/ide/docs/authoring/using_markdown">R Markdown</a>, but
any interactivity is within embedded modules, not <em>integral</em> to the text.
<a href="http://ipython.org/">IPython</a> offers a powerful executable document tool,
but it isn’t exactly a lightweight format.</p>
<h3><code>.litcoffee</code></h3>
<p>The recent release of <a href="http://coffeescript.org/#literate">literate CoffeeScript</a>
is a really nice approach to literate programming. It allows for writing a
Markdown file that can also be executed by actually running the code blocks.
The file can be either parsed as Markdown, for viewing as a nicely formatted
— yet still static — HTML page. Or, it can be compiled by the <code>coffee</code>
compiler into JavaScript and executed.</p>
<p>But what if the HTML representation weren’t static?</p>
<h2>Active Markdown</h2>
<h3>Interactivity</h3>
<p>Thanks to <code>coffee-script.js</code>, it's possible to compile and execute
CoffeeScript <em>in-browser</em>. This, combined with a little <code>Backbone</code> for
managing the variables and interface, and we get interactive controls that can
gather the state of all the variables, compile the CoffeeScript defined in the
code blocks, execute that code using the current state, and reapply the state
to the variables in the document.</p>
<p>Different controls and outputs can be specified. Even graphs can be embedded,
specifying a function and a range for the <code>x</code> values.</p>
<h3>Notation</h3>
<p>The notation is intended to be simple, and <em>feel</em> like Markdown. The approach
is use the normal link and image syntax, but with braces instead of
parenthesis and brackets. A simple interpolated variable looks like:
<code>[alt text/default]{var_name}</code>, where the text in the brackets is the
plaintext version of the variable (and also serves as a default value). The
token inside the braces is the name of the variable. Names are global, so
using the same variable name again will link those controls.</p>
<p>More complicated controls are specified by adding configuration inside the
braces, eg: <code>[5]{some_number [0...10]}</code> creates a slider from 0 to 10,
starting at <span class="live-text"  data-name="some_number" data-config='["[0...10]"]'>5</span>.</p>
<p>The type of control is determined by the configuration. A simple
<code>this or that</code> creates a binary choice between <span class="live-text"  data-name="which_one" data-config='["this", "or", "that"]'>this</span>.</p>
<p>Graphs are effectively embedded images, and the notation is similar.
<code>&lt;span class="live-text" data-graph="true" data-name="graphFn" data-config='["x=[-10...10]"]'&gt;Graph title&lt;/span&gt;</code> will create a graph driven by <code>graphFn</code>
over a range from <code>-10</code> to <code>10</code>.</p>
<p>The code of that function can connect the graph to other variables:</p>
<pre><code>@sinOfX = (x) =&gt;
    return Math.sin(@period * x)
</code></pre>
<p><span class="live-text" data-graph="true" data-name="sinOfX" data-config='["x=[0..12]"]'>sin of x</span> <span class="live-text"  data-name="period" data-config='["[1...6]"]'>1</span></p>
<p>These variables can then be combined in the code for more complex logic:</p>
<pre><code>coefficients =
    'profit' : 5
    'loss'   : -1

@q1_result = @some_number * coefficients[@revenue]

if @revenue is 'profit'
    @outlook = 'positive outlook'
else
    @outlook = 'negative outlook'
</code></pre>
<p>Choosing <span class="live-text"  data-name="revenue" data-config='["profit", "or", "loss"]'>profit</span> results in a <span class="live-text"  data-name="outlook" data-config='[]'>positive outlook</span>:  <span class="live-text"  data-name="q1_result" data-config='[]'>25</span>.</p>
<h3>Logic</h3>
<p>The code blocks, written using CoffeeScript, are used to tie the variables
together. When executing, every block is concatenated into a single
CoffeeScript source string. The code has access to the variables which are
attached to the top-level <code>this</code> in its scope.</p>
<p>At the beginning of the execution process, the current value for each variable
is gathered into a state. The code is then executed, using that state as its
<code>this</code> context. The code modifies the state and does whatever it does, then
the state is reapplied to each variable, updating the display of each control
and output in the document.</p>
<h4><code>contenteditable</code></h4>
<p>Changing parameters is great, but what if you want to challenge an author’s
assumptions about their logic? Each code block is directly editable, and
<em>recompiled</em> each time the document is executed. This means the logic and
relationships between the variables can be modified on the fly, and the
results seen immediately.</p>
<hr />
<p>The growth in our credit default swap operation shows no sign of slowing:</p>
<pre><code>rating = 2
@growth = (x) -&gt;
    return Math.pow(x,rating)
</code></pre>
<p><span class="live-text" data-graph="true" data-name="growth" data-config='["x=[0..2020]"]'>Money over time</span></p>
<hr />
<h2>Forward</h2>
<p>In a sense, Active Markdown is an inversion of literate CoffeeScript. Instead
of the document describing the code, <em>the code describes the document</em>.</p>
<p>Right now, this is just an experiment. The compilation command and
interactivity script are still in need of some user-friendliness and
robustness, but they are on <a href="https://github.com/alecperkins/active-markdown">GitHub</a>.</p>
<p>The plan going forward is to expand on the notation and add additional types
of controls, and add helpers for working with graphs and datasets. Also, more
refined controls (read: non-jQuery UI default) and a more useful editor for
the code blocks, perhaps <a href="http://codemirror.net/">CodeMirror</a>, are definitely
in order. Maybe the best approach is to actually use the Tangle controls?
Identifying additional usecases will help guide development.</p>
<p>Take a peek at the <a href="index.amd">raw <code>.amd</code> file</a> used to generate this document.</p>
<p><em>— <a href="https://twitter.com/alecperkins">@alecperkins</a>, 2013-3-14</em></p></div>
    <script src="http://code.jquery.com/jquery-1.9.1.js"></script>
    <script src="http://code.jquery.com/ui/1.10.1/jquery-ui.js"></script>
    <link href="http://code.jquery.com/ui/1.10.0/themes/base/jquery-ui.css" rel="stylesheet" type="text/css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.string/2.3.0/underscore.string.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.9.10/backbone-min.js"></script>
    <script src="https://raw.github.com/alecperkins/Backbone.NamedView/master/backbone.namedview.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.4.0/coffee-script.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/flot/0.7/jquery.flot.min.js"></script>
    <script>// Generated by CoffeeScript 1.6.1
(function() {
  var BinaryVar, Executor, GraphView, NumberVar, StringVar, Variable, buildBinaryVar, buildGraph, buildNumberVar, buildStringVar, executor, makeLive,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _.templateSettings = {
    interpolate: /\{\{(.+?)\}\}/g,
    evaluate: /\{\%(.+?)\%\}/g
  };

  Executor = (function() {

    function Executor() {
      var _this = this;
      this._deferredExecute = function() {
        return Executor.prototype._deferredExecute.apply(_this, arguments);
      };
      this._variables = {};
      $('pre code').on('blur', this._deferredExecute);
    }

    Executor.prototype.getOrCreateVariable = function(attrs) {
      var name, variable_model;
      name = attrs.name;
      if (this._variables[name]) {
        variable_model = this._variables[name];
        delete attrs.value;
      } else {
        variable_model = new Backbone.Model(name);
        this._variables[name] = variable_model;
        variable_model.on('change', this._deferredExecute);
      }
      variable_model.set(attrs);
      return variable_model;
    };

    Executor.prototype._prepareState = function() {
      var state;
      state = {};
      _.each(this._variables, function(v) {
        return state[v.get('name')] = v.get('value');
      });
      return state;
    };

    Executor.prototype._compileCode = function() {
      var coffee_code_str, js_code_str;
      coffee_code_str = '';
      $('pre code').each(function(i, el) {
        return coffee_code_str += $(el).text();
      });
      js_code_str = CoffeeScript.compile(coffee_code_str);
      return js_code_str;
    };

    Executor.prototype._deferredExecute = function() {
      var _this = this;
      if (!this._is_executing) {
        this._is_executing = true;
        return _.defer(function() {
          var fn, js_code_str, state;
          state = _this._prepareState();
          js_code_str = _this._compileCode();
          fn = Function(js_code_str);
          fn.call(state, js_code_str);
          _this._updateVariablesFrom(state);
          return _this._is_executing = false;
        });
      }
    };

    Executor.prototype._updateVariablesFrom = function(state) {
      var k, v, _ref, _results;
      _results = [];
      for (k in state) {
        v = state[k];
        _results.push((_ref = this._variables[k]) != null ? _ref.set({
          value: v
        }) : void 0);
      }
      return _results;
    };

    return Executor;

  })();

  executor = new Executor();

  makeLive = function(i, el) {
    var $tag, config, live_element, name, text_content;
    $tag = $(el);
    name = $tag.data('name');
    config = $tag.data('config');
    text_content = $tag.html();
    if ($tag.data('graph')) {
      live_element = buildGraph(text_content, name, config);
    } else if (config.length === 3 && config[1] === 'or') {
      live_element = buildBinaryVar(text_content, name, config);
    } else if (/[[\d]+[\.]{2,3}[\d]+]/.test(config[0])) {
      live_element = buildNumberVar(text_content, name, config);
    } else {
      live_element = buildStringVar(text_content, name, config);
    }
    return $tag.replaceWith(live_element.render());
  };

  Variable = (function(_super) {

    __extends(Variable, _super);

    function Variable() {
      var _this = this;
      this.render = function() {
        return Variable.prototype.render.apply(_this, arguments);
      };
      return Variable.__super__.constructor.apply(this, arguments);
    }

    Variable.prototype.tagName = 'span';

    Variable.prototype.initialize = function() {
      this.listenTo(this.model, 'change', this.render);
      return this._ui_map = _.extend({}, this.ui);
    };

    Variable.prototype.render = function() {
      var _this = this;
      this.ui = {};
      if (this.readonly) {
        this.$el.addClass('readonly');
      }
      _.defer(function() {
        var name, selector, _ref;
        _this.$el.html(_.template(_this.template)(_this.model.toJSON()));
        _ref = _this.ui_map;
        for (name in _ref) {
          selector = _ref[name];
          _this.ui[name] = _this.$el.find(selector);
        }
        return _this.onRender();
      });
      return this.el;
    };

    Variable.prototype.onRender = function() {};

    return Variable;

  })(Backbone.NamedView);

  NumberVar = (function(_super) {

    __extends(NumberVar, _super);

    function NumberVar() {
      var _this = this;
      this._update = function(e, ui) {
        return NumberVar.prototype._update.apply(_this, arguments);
      };
      return NumberVar.__super__.constructor.apply(this, arguments);
    }

    NumberVar.prototype.ui_map = {
      slider: 'span.slider',
      output: 'span.output'
    };

    NumberVar.prototype._update = function(e, ui) {
      return this.model.set({
        value: parseInt(ui.value)
      });
    };

    NumberVar.prototype.template = "<span class=\"variable-label\">{{ name }}</span>\n<span class=\"slider\"></span>\n<span class=\"output\">{{ value }}</span>";

    NumberVar.prototype.onRender = function() {
      var _this = this;
      return this.ui.slider.slider({
        min: this.model.get('min'),
        max: this.model.get('max'),
        value: this.model.get('value'),
        change: this._update,
        slide: function(e, ui) {
          return _this.ui.output.text(ui.value);
        }
      });
    };

    return NumberVar;

  })(Variable);

  buildNumberVar = function(text_content, name, config) {
    var max, min, number_model, variable_view;
    config = _.string.strip(config[0], '][').split('.');
    min = _.first(config);
    max = _.last(config);
    text_content = _.string.strip(text_content, '$%');
    number_model = executor.getOrCreateVariable({
      name: name,
      min: parseInt(min),
      max: parseInt(max),
      value: parseInt(text_content)
    });
    variable_view = new NumberVar({
      model: number_model
    });
    return variable_view;
  };

  BinaryVar = (function(_super) {

    __extends(BinaryVar, _super);

    function BinaryVar() {
      return BinaryVar.__super__.constructor.apply(this, arguments);
    }

    BinaryVar.prototype.template = "<span class=\"variable-label\">{{ name }}</span>\n<label><input class=\"option-a\" name=\"{{ name }}\" type=\"radio\" value=\"{{ a }}\">{{ a }}</label>\n<label><input class=\"option-b\" name=\"{{ name }}\" type=\"radio\" value=\"{{ b }}\">{{ b }}</label>";

    BinaryVar.prototype.onRender = function() {
      var a, b, value, _ref;
      _ref = this.model.toJSON(), value = _ref.value, a = _ref.a, b = _ref.b;
      if (value === a) {
        return this.$el.find('.option-a').attr('checked', true);
      } else if (value === b) {
        return this.$el.find('.option-b').attr('checked', true);
      }
    };

    BinaryVar.prototype.events = {
      'change input': '_update'
    };

    BinaryVar.prototype.ui_map = {
      'a': '.option-a',
      'b': '.option-b'
    };

    BinaryVar.prototype._update = function() {
      if (this.ui.a.is(':checked')) {
        return this.model.set('value', this.ui.a.val());
      } else if (this.ui.b.is(':checked')) {
        return this.model.set('value', this.ui.b.val());
      }
    };

    return BinaryVar;

  })(Variable);

  buildBinaryVar = function(text_content, name, config) {
    var var_model, variable_view;
    var_model = executor.getOrCreateVariable({
      name: name,
      value: text_content,
      a: config[0],
      b: config[2]
    });
    variable_view = new BinaryVar({
      model: var_model
    });
    return variable_view;
  };

  StringVar = (function(_super) {

    __extends(StringVar, _super);

    function StringVar() {
      return StringVar.__super__.constructor.apply(this, arguments);
    }

    StringVar.prototype.readonly = true;

    StringVar.prototype.template = "<span class=\"variable-label\">{{ name }}</span>\n{% if(value.toFixed) { %}\n    {{ value.toFixed(1) }}\n{% } else { %}\n    {{ value }}\n{% } %}";

    return StringVar;

  })(Variable);

  buildStringVar = function(text_content, name, config) {
    var var_model, variable_view;
    var_model = executor.getOrCreateVariable({
      name: name,
      value: text_content
    });
    variable_view = new StringVar({
      model: var_model
    });
    return variable_view;
  };

  GraphView = (function(_super) {

    __extends(GraphView, _super);

    function GraphView() {
      return GraphView.__super__.constructor.apply(this, arguments);
    }

    GraphView.prototype.readonly = true;

    GraphView.prototype.tagName = 'div';

    GraphView.prototype.template = "<div class=\"graph-title\">{{ title }}</div>\n<div class=\"graph-canvas\"></div>";

    GraphView.prototype.ui_map = {
      'canvas': '.graph-canvas'
    };

    GraphView.prototype.onRender = function() {
      this.ui.canvas.css({
        height: this.ui.canvas.width() / 2
      });
      return this._generateGraph();
    };

    GraphView.prototype._generateGraph = function() {
      var config, end, graphFn, series, start, x, x_range, _i;
      config = this.model.get('config');
      x_range = config[0].split('=')[1];
      x_range = _.string.strip(x_range, '[]').split('.');
      start = parseInt(_.first(x_range));
      end = parseInt(_.last(x_range));
      series = [];
      graphFn = this.model.get('value');
      for (x = _i = start; 0.1 > 0 ? _i < end : _i > end; x = _i += 0.1) {
        series.push([x, graphFn(x)]);
      }
      return $.plot(this.ui.canvas, [series]);
    };

    return GraphView;

  })(Variable);

  buildGraph = function(text_content, name, config) {
    var graph_view, var_model;
    var_model = executor.getOrCreateVariable({
      name: name,
      title: text_content,
      config: config
    });
    graph_view = new GraphView({
      model: var_model
    });
    return graph_view;
  };

  $('.live-text').each(makeLive);

  $('pre code').each(function(i, code) {
    return $(code).attr('contenteditable', true);
  });

}).call(this);
</script>
</body>
</html>